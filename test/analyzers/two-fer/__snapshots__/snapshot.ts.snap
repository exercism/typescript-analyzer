// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/0's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/1's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/2's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name?: string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name?: string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/3's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name?: string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name?: string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_explicity_default_value",
      "message": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of 'name' to
'you'.",
      "template": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of '%{parameter}' to
'you'.",
      "type": "actionable",
      "variables": Object {
        "maybe_undefined_expression": "name",
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/5's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/7's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name : string = \\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name : string = \\"you\\" ) ...",
      },
    },
  ],
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/10's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name:string=\\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name:string=\\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/11's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/12's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/13's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/14's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string= \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string= \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/15's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( s = \\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( s = \\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/16's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name:string=\\"you\\" /* Parameters go here */ ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name:string=\\"you\\" /* Parameters go here */ ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/17's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/18's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/19's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/20's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/21's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/22's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.no_named_export",
      "message": "No [export](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export) called \`twoFer\`.
The tests won't pass without it.

Did you forget adding: \`export twoFer\`?",
      "template": "No [export](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export) called \`%{export.name}\`.
The tests won't pass without it.

Did you forget adding: \`export %{export.name}\`?",
      "type": "essential",
      "variables": Object {
        "export.name": "twoFer",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/23's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/24's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(id: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(id: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/25's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  public static readonly twoFer = (name: string = 'you'): string =>
    \`One for \${name}, one for me.\`: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "public static readonly twoFer = (name: string = 'you'): string =>
    \`One for \${name}, one for me.\`",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/26's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/27's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(X:string=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(X:string=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/28's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/29's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/30's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/31's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string='') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string='') ...",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/32's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/33's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/34's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/40's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/41's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(x: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(x: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/42's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/45's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string) ...",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/48's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name?: string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name?: string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/53's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string=\\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string=\\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/54's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name1: string=\\"you\\",name2: string=\\"me\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name1: string=\\"you\\",name2: string=\\"me\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.redirect_incorrect_string_template",
      "message": "The string template looks incorrect. Expected a template with 3 components.",
      "template": "The string template looks incorrect. Expected a template with 3 components.",
      "type": "essential",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/60's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_explicity_default_value",
      "message": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of 'name' to
'you'.",
      "template": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of '%{parameter}' to
'you'.",
      "type": "actionable",
      "variables": Object {
        "maybe_undefined_expression": "name",
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/100's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/101's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(who: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(who: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/102's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name?: string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name?: string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/103's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string='you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string='you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/104's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/105's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(who = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(who = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/106's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( x: string = 'you' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( x: string = 'you' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/107's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [],
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/108's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/109's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/110's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/111's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string = \\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string = \\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/112's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name?: string ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name?: string ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/113's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string= \\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string= \\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/114's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/115's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name:string=\\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name:string=\\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/116's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string | null = null) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string | null = null) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_explicity_default_value",
      "message": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of 'name' to
'you'.",
      "template": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of '%{parameter}' to
'you'.",
      "type": "actionable",
      "variables": Object {
        "maybe_undefined_expression": "name",
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/117's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/118's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/119's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/120's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name?: string ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name?: string ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/121's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "type": "essential",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/122's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/123's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/124's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/125's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name='you' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name='you' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/126's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/127's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/128's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(person: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(person: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/129's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/130's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string='you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string='you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/131's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(person = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(person = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/132's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "type": "essential",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/133's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name?: string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name?: string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/134's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/135's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/136's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/137's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(param: string=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(param: string=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/138's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/139's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name:string=\\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name:string=\\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/140's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/141's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/142's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(aName = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(aName = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of aName to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "aName",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/143's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name='you' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name='you' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/144's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"aLiCe\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"aLiCe\\") ...",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/145's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/146's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/147's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/148's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(you: string = \\"you\\", me: string = \\"me\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(you: string = \\"you\\", me: string = \\"me\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.redirect_incorrect_string_template",
      "message": "The string template looks incorrect. Expected a template with 3 components.",
      "template": "The string template looks incorrect. Expected a template with 3 components.",
      "type": "essential",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/149's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/150's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "type": "essential",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/151's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name?: string ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name?: string ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/152's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/153's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "type": "essential",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/154's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name:string=\\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name:string=\\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/155's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name:string=\\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name:string=\\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/156's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/157's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name?: string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name?: string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_strict_equality",
      "message": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "template": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "type": "actionable",
      "variables": Object {},
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/158's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/159's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name = 'you' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name = 'you' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/160's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name:string=\\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name:string=\\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/161's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string=\\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string=\\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/162's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/163's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/164's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/165's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/166's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string = \\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string = \\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/167's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "type": "essential",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/168's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/169's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "type": "essential",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/171's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(message:string=\\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(message:string=\\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/172's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/173's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(x: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(x: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/174's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/175's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name = \\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name = \\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/176's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/177's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( message:string = \\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( message:string = \\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/178's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string=\\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string=\\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/179's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/180's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(input: string = \\"\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(input: string = \\"\\") ...",
      },
    },
  ],
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/181's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/182's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/183's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name = 'you') ...",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/184's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string = 'you' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string = 'you' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/185's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/186's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = '') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = '') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/187's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/188's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/189's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name : string=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name : string=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/190's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name = 'you'  ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name = 'you'  ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/191's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string='') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string='') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/192's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/193's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name?: string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name?: string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/194's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/195's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/196's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/197's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string='you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string='you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/198's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string = '' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string = '' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/199's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/200's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/201's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/202's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(who: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(who: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/203's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/204's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(text: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(text: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/205's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/206's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/207's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/208's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/209's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/210's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/211's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.no_named_export",
      "message": "No [export](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export) called \`twoFer\`.
The tests won't pass without it.

Did you forget adding: \`export twoFer\`?",
      "template": "No [export](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export) called \`%{export.name}\`.
The tests won't pass without it.

Did you forget adding: \`export %{export.name}\`?",
      "type": "essential",
      "variables": Object {
        "export.name": "twoFer",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/212's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string = 'you' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string = 'you' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/213's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/214's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( input: string='you' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( input: string='you' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/215's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string = \\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string = \\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/216's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/217's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/218's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name:string = 'Alice') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name:string = 'Alice') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_explicity_default_value",
      "message": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of 'name' to
'you'.",
      "template": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of '%{parameter}' to
'you'.",
      "type": "actionable",
      "variables": Object {
        "maybe_undefined_expression": "name",
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/219's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/220's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/221's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name?: string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name?: string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_explicity_default_value",
      "message": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of 'name' to
'you'.",
      "template": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of '%{parameter}' to
'you'.",
      "type": "actionable",
      "variables": Object {
        "maybe_undefined_expression": "name",
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/222's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string = \\"\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string = \\"\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/223's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.no_named_export",
      "message": "No [export](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export) called \`twoFer\`.
The tests won't pass without it.

Did you forget adding: \`export twoFer\`?",
      "template": "No [export](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export) called \`%{export.name}\`.
The tests won't pass without it.

Did you forget adding: \`export %{export.name}\`?",
      "type": "essential",
      "variables": Object {
        "export.name": "twoFer",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/224's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/225's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/226's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/227's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(addresse:string=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(addresse:string=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/228's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string = \\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string = \\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/229's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( message:string=\\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( message:string=\\"you\\" ) ...",
      },
    },
  ],
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/230's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/231's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/232's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name?: string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name?: string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_strict_equality",
      "message": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "template": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "type": "actionable",
      "variables": Object {},
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/233's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/234's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/235's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( str:string=\\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( str:string=\\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/236's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/237's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name:string=\\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name:string=\\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/238's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/239's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer = (name: string = 'you'): string => \`One for \${name}, one for me.\`: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer = (name: string = 'you'): string => \`One for \${name}, one for me.\`",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/240's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string = \\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string = \\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/241's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/242's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string = \\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string = \\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/243's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/244's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name:string ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name:string ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_strict_equality",
      "message": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "template": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "type": "actionable",
      "variables": Object {},
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/245's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_strict_equality",
      "message": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "template": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "type": "actionable",
      "variables": Object {},
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/246's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/247's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/248's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/249's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/250's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/251's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(who?: string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(who?: string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of who to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "who",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/252's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/253's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/254's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(input?:string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(input?:string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of input to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "input",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/255's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(who = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(who = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/256's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/257's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( msg = 'you' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( msg = 'you' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/258's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string = 'you' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string = 'you' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/259's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name?: string | undefined) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name?: string | undefined) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/260's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer = ( n: string = 'you' ): string =>
    \`One for \${n}, one for me.\`: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer = ( n: string = 'you' ): string =>
    \`One for \${n}, one for me.\`",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/261's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/262's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/263's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/264's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name:string=\\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name:string=\\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/265's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(msg: string=\\"\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(msg: string=\\"\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of msg to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "msg",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/266's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/267's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/268's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/269's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/270's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/271's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/272's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/273's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name = \\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name = \\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/274's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string = 'you' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string = 'you' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/275's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name:string=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name:string=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/276's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/277's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/278's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name:string='you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name:string='you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/279's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"\\") ...",
      },
    },
  ],
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/280's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(who: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(who: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/281's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/282's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/283's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/284's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer = (name: string = 'you'): string => \`One for \${name || 'you'}, one for me.\`: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer = (name: string = 'you'): string => \`One for \${name || 'you'}, one for me.\`",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/285's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string=\\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string=\\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/287's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string = \\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string = \\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/288's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/289's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( who: string = 'you' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( who: string = 'you' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/290's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( who: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( who: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/291's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.no_named_export",
      "message": "No [export](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export) called \`twoFer\`.
The tests won't pass without it.

Did you forget adding: \`export twoFer\`?",
      "template": "No [export](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export) called \`%{export.name}\`.
The tests won't pass without it.

Did you forget adding: \`export %{export.name}\`?",
      "type": "essential",
      "variables": Object {
        "export.name": "twoFer",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/292's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/293's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name:string =\\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name:string =\\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/295's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/296's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/297's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/298's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "type": "essential",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/299's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer (name: string='') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer (name: string='') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/300's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/301's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/302's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string = 'you' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string = 'you' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/303's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/304's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/305's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name?: string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name?: string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/306's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/307's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/308's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(who?: string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(who?: string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of who to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "who",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/309's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/310's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/311's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(who: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(who: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/312's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/313's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name?: string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name?: string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/314's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer = (name: string = 'you') => \`One for \${name}, one for me.\`: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer = (name: string = 'you') => \`One for \${name}, one for me.\`",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/315's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/316's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string = 'you' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string = 'you' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/317's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/318's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/319's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/320's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = '') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = '') ...",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/321's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = '') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = '') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_explicity_default_value",
      "message": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of 'name' to
'you'.",
      "template": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of '%{parameter}' to
'you'.",
      "type": "actionable",
      "variables": Object {
        "maybe_undefined_expression": "name",
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/322's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/323's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/324's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "type": "essential",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/325's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/326's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/327's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_strict_equality",
      "message": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "template": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "type": "actionable",
      "variables": Object {},
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/328's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string = 'you' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string = 'you' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/329's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name?:string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name?:string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/330's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name=\\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name=\\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/331's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "type": "essential",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/332's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.no_named_export",
      "message": "No [export](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export) called \`twoFer\`.
The tests won't pass without it.

Did you forget adding: \`export twoFer\`?",
      "template": "No [export](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export) called \`%{export.name}\`.
The tests won't pass without it.

Did you forget adding: \`export %{export.name}\`?",
      "type": "essential",
      "variables": Object {
        "export.name": "twoFer",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/333's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name:string = 'you' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name:string = 'you' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/334's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/335's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "type": "essential",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/336's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string = \\"you\\"):String ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string = \\"you\\"):String ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/337's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name:string='you' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name:string='you' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/338's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(firstPerson:string=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(firstPerson:string=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/339's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string = \\"you\\") : String ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string = \\"you\\") : String ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/340's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/341's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(who: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(who: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/342's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "type": "informative",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/344's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name?: string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name?: string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/354's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name?: string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name?: string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/355's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_strict_equality",
      "message": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "template": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "type": "actionable",
      "variables": Object {},
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/358's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = '') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = '') ...",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/365's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer = (name?: string): string => \`One for \${name || 'you'}, one for me.\`: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer = (name?: string): string => \`One for \${name || 'you'}, one for me.\`",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_explicity_default_value",
      "message": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of 'name' to
'you'.",
      "template": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of '%{parameter}' to
'you'.",
      "type": "actionable",
      "variables": Object {
        "maybe_undefined_expression": "name",
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/366's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [],
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/367's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "type": "essential",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/368's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name?: string ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name?: string ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/370's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "type": "essential",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/371's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/375's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name:string='' ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name:string='' ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/376's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( towhom:string=\\"you\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( towhom:string=\\"you\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/383's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name1:string=\\"you\\", name2:string=\\"me\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name1:string=\\"you\\", name2:string=\\"me\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.redirect_incorrect_string_template",
      "message": "The string template looks incorrect. Expected a template with 3 components.",
      "template": "The string template looks incorrect. Expected a template with 3 components.",
      "type": "essential",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/391's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/403's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(who:string=\\"\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(who:string=\\"\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of who to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "who",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/405's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "type": "essential",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/410's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = 'you') ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = 'you') ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/415's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/416's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(_input?:string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(_input?:string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of _input to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "_input",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/422's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/423's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/427's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name:string=\`you\` ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name:string=\`you\` ) ...",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/433's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/434's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name?: string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name?: string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/436's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name?: string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name?: string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_explicity_default_value",
      "message": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of 'name' to
'you'.",
      "template": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of '%{parameter}' to
'you'.",
      "type": "actionable",
      "variables": Object {
        "maybe_undefined_expression": "name",
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/438's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/439's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "type": "essential",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/440's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( /* Parameters go here */ name?: string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( /* Parameters go here */ name?: string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/442's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer( name : string =\\"you\\", name1: string =\\"Alice\\" , name2: string =\\"Bob\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer( name : string =\\"you\\", name1: string =\\"Alice\\" , name2: string =\\"Bob\\" ) ...",
      },
    },
  ],
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/444's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"Alice\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"Alice\\") ...",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/454's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string=\\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string=\\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/470's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name: string = \\"you\\") ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name: string = \\"you\\") ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "type": "actionable",
      "variables": Object {},
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/481's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(name:string=\\"\\" ) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(name:string=\\"\\" ) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/484's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "type": "essential",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "summary": undefined,
}
`;

exports[`When running analysis on two-fer fixtures and expecting matches two-fer/497's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  static twoFer(person?: string) ...: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "type": "actionable",
      "variables": Object {
        "signature": "static twoFer(person?: string) ...",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of person to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "type": "actionable",
      "variables": Object {
        "parameter": "person",
      },
    },
  ],
  "summary": undefined,
}
`;
